create extension if not exists pgcrypto;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create table if not exists rooms (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  slug text not null unique,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists assets (
  id uuid primary key default gen_random_uuid(),
  room_id uuid not null references rooms(id) on delete cascade,
  title text not null,
  description text,
  current_version text not null,
  image_url text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  edited_by text not null
);

alter table assets add column if not exists description text;

create table if not exists asset_tags (
  id uuid primary key default gen_random_uuid(),
  asset_id uuid not null references assets(id) on delete cascade,
  tag text not null
);

create table if not exists asset_versions (
  id uuid primary key default gen_random_uuid(),
  asset_id uuid not null references assets(id) on delete cascade,
  version text not null,
  prompt text not null,
  image_url text,
  output_type text not null default 'image',
  response_text text,
  size text not null,
  style text not null,
  notes text,
  editor text not null,
  created_at timestamptz not null default now()
);

alter table asset_versions add column if not exists image_url text;
alter table asset_versions add column if not exists output_type text not null default 'image';
alter table asset_versions add column if not exists response_text text;

-- Backfill any historical "current" version rows with the asset cover image.
update asset_versions av
set image_url = a.image_url
from assets a
where av.asset_id = a.id
  and av.version = a.current_version
  and av.image_url is null;

create table if not exists annotations (
  id bigint generated by default as identity primary key,
  asset_id uuid not null references assets(id) on delete cascade,
  number integer not null,
  x_position numeric not null,
  y_position numeric not null,
  created_at timestamptz not null default now()
);

create table if not exists comments (
  id uuid primary key default gen_random_uuid(),
  asset_id uuid not null references assets(id) on delete cascade,
  author text not null,
  avatar_url text not null,
  content text not null,
  created_at timestamptz not null default now()
);

create index if not exists assets_room_id_idx on assets(room_id);
create index if not exists asset_tags_asset_id_idx on asset_tags(asset_id);
create index if not exists asset_versions_asset_id_idx on asset_versions(asset_id);
create index if not exists annotations_asset_id_idx on annotations(asset_id);
create index if not exists comments_asset_id_idx on comments(asset_id);

create unique index if not exists asset_versions_unique_version_idx on asset_versions(asset_id, version);
create unique index if not exists annotations_asset_number_idx on annotations(asset_id, number);

-- Project domain views:
-- Workspace items are "projects" in the product model.
-- These views keep existing asset tables intact while exposing project-first naming.
create or replace view projects as
select
  id,
  room_id,
  title,
  description,
  current_version,
  image_url,
  created_at,
  updated_at,
  edited_by
from assets;

create or replace view project_tags as
select
  id,
  asset_id as project_id,
  tag
from asset_tags;

create or replace view project_versions as
select
  id,
  asset_id as project_id,
  version,
  prompt,
  image_url,
  output_type,
  response_text,
  size,
  style,
  notes,
  editor,
  created_at
from asset_versions;

create or replace view project_annotations as
select
  id,
  asset_id as project_id,
  number,
  x_position,
  y_position,
  created_at
from annotations;

create or replace view project_comments as
select
  id,
  asset_id as project_id,
  author,
  avatar_url,
  content,
  created_at
from comments;

alter table rooms enable row level security;
alter table assets enable row level security;
alter table asset_tags enable row level security;
alter table asset_versions enable row level security;
alter table annotations enable row level security;
alter table comments enable row level security;

drop policy if exists "rooms_public_read" on rooms;
create policy "rooms_public_read" on rooms
for select to public
using (true);

drop policy if exists "rooms_authenticated_write" on rooms;
create policy "rooms_authenticated_write" on rooms
for all to authenticated
using (true)
with check (true);

drop policy if exists "assets_public_read" on assets;
create policy "assets_public_read" on assets
for select to public
using (true);

drop policy if exists "assets_authenticated_write" on assets;
create policy "assets_authenticated_write" on assets
for all to authenticated
using (true)
with check (true);

drop policy if exists "asset_tags_public_read" on asset_tags;
create policy "asset_tags_public_read" on asset_tags
for select to public
using (true);

drop policy if exists "asset_tags_authenticated_write" on asset_tags;
create policy "asset_tags_authenticated_write" on asset_tags
for all to authenticated
using (true)
with check (true);

drop policy if exists "asset_versions_public_read" on asset_versions;
create policy "asset_versions_public_read" on asset_versions
for select to public
using (true);

drop policy if exists "asset_versions_authenticated_write" on asset_versions;
create policy "asset_versions_authenticated_write" on asset_versions
for all to authenticated
using (true)
with check (true);

drop policy if exists "annotations_public_read" on annotations;
create policy "annotations_public_read" on annotations
for select to public
using (true);

drop policy if exists "annotations_authenticated_write" on annotations;
create policy "annotations_authenticated_write" on annotations
for all to authenticated
using (true)
with check (true);

drop policy if exists "comments_public_read" on comments;
create policy "comments_public_read" on comments
for select to public
using (true);

drop policy if exists "comments_authenticated_write" on comments;
create policy "comments_authenticated_write" on comments
for all to authenticated
using (true)
with check (true);

drop trigger if exists rooms_set_updated_at on rooms;
create trigger rooms_set_updated_at
before update on rooms
for each row
execute function public.set_updated_at();

drop trigger if exists assets_set_updated_at on assets;
create trigger assets_set_updated_at
before update on assets
for each row
execute function public.set_updated_at();

insert into storage.buckets (id, name, public)
values ('asset-images', 'asset-images', true)
on conflict (id) do nothing;

drop policy if exists "asset_images_public_read" on storage.objects;
create policy "asset_images_public_read"
on storage.objects
for select to public
using (bucket_id = 'asset-images');

drop policy if exists "asset_images_authenticated_write" on storage.objects;
create policy "asset_images_authenticated_write"
on storage.objects
for all to authenticated
using (bucket_id = 'asset-images')
with check (bucket_id = 'asset-images');

do $$
begin
  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'rooms'
  ) then
    execute 'alter publication supabase_realtime add table public.rooms';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'assets'
  ) then
    execute 'alter publication supabase_realtime add table public.assets';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'asset_tags'
  ) then
    execute 'alter publication supabase_realtime add table public.asset_tags';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'asset_versions'
  ) then
    execute 'alter publication supabase_realtime add table public.asset_versions';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'annotations'
  ) then
    execute 'alter publication supabase_realtime add table public.annotations';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'comments'
  ) then
    execute 'alter publication supabase_realtime add table public.comments';
  end if;
end $$;

create table if not exists organizations (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  slug text not null unique,
  website text,
  contact_email text,
  phone text,
  address_line1 text,
  address_line2 text,
  city text,
  state text,
  postal_code text,
  country text,
  logo_storage_path text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists team_members (
  id uuid primary key default gen_random_uuid(),
  organization_id uuid not null references organizations(id) on delete cascade,
  user_id uuid not null,
  display_name text,
  role text not null check (role in ('admin', 'editor', 'viewer')),
  created_at timestamptz not null default now(),
  unique (organization_id, user_id)
);

alter table team_members add column if not exists display_name text;

create table if not exists api_settings (
  id uuid primary key default gen_random_uuid(),
  organization_id uuid not null unique references organizations(id) on delete cascade,
  provider text,
  model text,
  default_image_size text,
  default_params jsonb not null default '{}'::jsonb,
  encrypted_api_key text,
  updated_at timestamptz not null default now(),
  updated_by uuid
);

create table if not exists usage_metrics (
  id uuid primary key default gen_random_uuid(),
  organization_id uuid not null references organizations(id) on delete cascade,
  month text not null,
  images_generated int not null default 0,
  storage_used_mb numeric not null default 0,
  api_calls int not null default 0,
  unique (organization_id, month)
);

create index if not exists team_members_org_idx on team_members (organization_id);
create index if not exists team_members_user_idx on team_members (user_id);
create index if not exists usage_metrics_org_month_idx on usage_metrics (organization_id, month);

drop trigger if exists organizations_set_updated_at on organizations;
create trigger organizations_set_updated_at
before update on organizations
for each row
execute function public.set_updated_at();

drop trigger if exists api_settings_set_updated_at on api_settings;
create trigger api_settings_set_updated_at
before update on api_settings
for each row
execute function public.set_updated_at();

alter table organizations enable row level security;
alter table team_members enable row level security;
alter table api_settings enable row level security;
alter table usage_metrics enable row level security;

drop policy if exists "organizations_select_member" on organizations;
create policy "organizations_select_member"
on organizations for select
using (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = organizations.id
      and tm.user_id = auth.uid()
  )
);

drop policy if exists "organizations_update_admin" on organizations;
create policy "organizations_update_admin"
on organizations for update
using (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = organizations.id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = organizations.id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
);

drop policy if exists "team_members_select_org_member" on team_members;
create policy "team_members_select_org_member"
on team_members for select
using (
  exists (
    select 1
    from team_members me
    where me.organization_id = team_members.organization_id
      and me.user_id = auth.uid()
  )
);

drop policy if exists "team_members_insert_admin" on team_members;
create policy "team_members_insert_admin"
on team_members for insert
with check (
  exists (
    select 1
    from team_members me
    where me.organization_id = team_members.organization_id
      and me.user_id = auth.uid()
      and me.role = 'admin'
  )
);

drop policy if exists "team_members_update_admin" on team_members;
create policy "team_members_update_admin"
on team_members for update
using (
  exists (
    select 1
    from team_members me
    where me.organization_id = team_members.organization_id
      and me.user_id = auth.uid()
      and me.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from team_members me
    where me.organization_id = team_members.organization_id
      and me.user_id = auth.uid()
      and me.role = 'admin'
  )
);

drop policy if exists "team_members_delete_admin" on team_members;
create policy "team_members_delete_admin"
on team_members for delete
using (
  exists (
    select 1
    from team_members me
    where me.organization_id = team_members.organization_id
      and me.user_id = auth.uid()
      and me.role = 'admin'
  )
);

drop policy if exists "api_settings_select_admin" on api_settings;
create policy "api_settings_select_admin"
on api_settings for select
using (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = api_settings.organization_id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
);

drop policy if exists "api_settings_insert_admin" on api_settings;
create policy "api_settings_insert_admin"
on api_settings for insert
with check (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = api_settings.organization_id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
);

drop policy if exists "api_settings_update_admin" on api_settings;
create policy "api_settings_update_admin"
on api_settings for update
using (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = api_settings.organization_id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = api_settings.organization_id
      and tm.user_id = auth.uid()
      and tm.role = 'admin'
  )
);

drop policy if exists "usage_metrics_select_org_member" on usage_metrics;
create policy "usage_metrics_select_org_member"
on usage_metrics for select
using (
  exists (
    select 1
    from team_members tm
    where tm.organization_id = usage_metrics.organization_id
      and tm.user_id = auth.uid()
  )
);

insert into storage.buckets (id, name, public)
values ('bandjoes-assets', 'bandjoes-assets', true)
on conflict (id) do nothing;

drop policy if exists "bandjoes_assets_public_read" on storage.objects;
create policy "bandjoes_assets_public_read"
  on storage.objects for select
  using (bucket_id = 'bandjoes-assets');

drop policy if exists "bandjoes_assets_authenticated_write" on storage.objects;
create policy "bandjoes_assets_authenticated_write"
  on storage.objects for all
  to authenticated
  using (bucket_id = 'bandjoes-assets')
  with check (bucket_id = 'bandjoes-assets');
